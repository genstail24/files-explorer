// @bun
var U=(z,q)=>{const v=q?.length?{}:null;if(v)for(let K of q)v[K.part.charCodeAt(0)]=K;return{part:z,store:null,inert:v,params:null,wildcardStore:null}},_=(z,q)=>({...z,part:q}),$=(z)=>({name:z,store:null,inert:null});class Y{root={};history=[];static regex={static:/:.+?(?=\/|$)/,params:/:.+?(?=\/|$)/g,optionalParams:/:.+?\?(?=\/|$)/g};add(z,q,v,{ignoreError:K=!1,ignoreHistory:V=!1}={}){if(typeof q!=="string")throw new TypeError("Route path must be a string");if(q==="")q="/";else if(q[0]!=="/")q=`/${q}`;const S=q[q.length-1]==="*",D=q.match(Y.regex.optionalParams);if(D){const F=q.replaceAll("?","");this.add(z,F,v,{ignoreError:K});for(let B=0;B<D.length;B++){let A=q.replace("/"+D[B],"");this.add(z,A,v,{ignoreError:!0})}return v}if(D)q=q.replaceAll("?","");if(this.history.find(([F,B,A])=>F===z&&B===q))return v;if(S||D&&q.charCodeAt(q.length-1)===63)q=q.slice(0,-1);if(!V)this.history.push([z,q,v]);const G=q.split(Y.regex.static),J=q.match(Y.regex.params)||[];if(G[G.length-1]==="")G.pop();let b;if(!this.root[z])b=this.root[z]=U("/");else b=this.root[z];let Q=0;for(let F=0;F<G.length;++F){let B=G[F];if(F>0){const A=J[Q++].slice(1);if(b.params===null)b.params=$(A);else if(b.params.name!==A)if(K)return v;else throw new Error(`Cannot create route "${q}" with parameter "${A}" `+"because a route already exists with a different parameter name "+`("${b.params.name}") in the same location`);const O=b.params;if(O.inert===null){b=O.inert=U(B);continue}b=O.inert}for(let A=0;;){if(A===B.length){if(A<b.part.length){const O=_(b,b.part.slice(A));Object.assign(b,U(B,[O]))}break}if(A===b.part.length){if(b.inert===null)b.inert={};const O=b.inert[B.charCodeAt(A)];if(O){b=O,B=B.slice(A),A=0;continue}const X=U(B.slice(A));b.inert[B.charCodeAt(A)]=X,b=X;break}if(B[A]!==b.part[A]){const O=_(b,b.part.slice(A)),X=U(B.slice(A));Object.assign(b,U(b.part.slice(0,A),[O,X])),b=X;break}++A}}if(Q<J.length){const B=J[Q].slice(1);if(b.params===null)b.params=$(B);else if(b.params.name!==B)if(K)return v;else throw new Error(`Cannot create route "${q}" with parameter "${B}" `+"because a route already exists with a different parameter name "+`("${b.params.name}") in the same location`);if(b.params.store===null)b.params.store=v;return b.params.store}if(S){if(b.wildcardStore===null)b.wildcardStore=v;return b.wildcardStore}if(b.store===null)b.store=v;return b.store}find(z,q){const v=this.root[z];if(!v)return null;return Z(q,q.length,v,0)}}var Z=(z,q,v,K)=>{const V=v.part,S=V.length,D=K+S;if(S>1){if(D>q)return null;if(S<15){for(let G=1,J=K+1;G<S;++G,++J)if(V.charCodeAt(G)!==z.charCodeAt(J))return null}else if(z.slice(K,D)!==V)return null}if(D===q){if(v.store!==null)return{store:v.store,params:{}};if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{"*":""}};return null}if(v.inert!==null){const G=v.inert[z.charCodeAt(D)];if(G!==void 0){const J=Z(z,q,G,D);if(J!==null)return J}}if(v.params!==null){const{store:G,name:J,inert:b}=v.params,Q=z.indexOf("/",D);if(Q!==D){if(Q===-1||Q>=q){if(G!==null){const F={};return F[J]=z.substring(D,q),{store:G,params:F}}}else if(b!==null){const F=Z(z,q,b,Q);if(F!==null)return F.params[J]=z.substring(D,Q),F}}}if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{"*":z.substring(D,q)}};return null},T=Y;export{T as default,Y as Memoirist};

//# debugId=1E61A6F427AA7FBE64756e2164756e21

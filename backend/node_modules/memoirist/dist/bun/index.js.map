{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": [
    "export interface FindResult<T> {\n    store: T\n    params: Record<string, any>\n}\n\nexport interface ParamNode<T> {\n    name: string\n    store: T | null\n    inert: Node<T> | null\n}\n\nexport interface Node<T> {\n    part: string\n    store: T | null\n    inert: Record<number, Node<T>> | null\n    params: ParamNode<T> | null\n    wildcardStore: T | null\n}\n\nconst createNode = <T>(part: string, inert?: Node<T>[]): Node<T> => {\n    const inertMap: Record<number, Node<T>> | null = inert?.length ? {} : null\n\n    if (inertMap)\n        for (const child of inert!) inertMap[child.part.charCodeAt(0)] = child\n\n    return {\n        part,\n        store: null,\n        inert: inertMap,\n        params: null,\n        wildcardStore: null\n    }\n}\n\nconst cloneNode = <T>(node: Node<T>, part: string) => ({\n    ...node,\n    part\n})\n\nconst createParamNode = <T>(name: string): ParamNode<T> => ({\n    name,\n    store: null,\n    inert: null\n})\n\nexport class Memoirist<T> {\n    root: Record<string, Node<T>> = {}\n    history: [string, string, T][] = []\n\n    private static regex = {\n        static: /:.+?(?=\\/|$)/,\n        params: /:.+?(?=\\/|$)/g,\n        optionalParams: /:.+?\\?(?=\\/|$)/g\n    }\n\n    add(\n        method: string,\n        path: string,\n        store: T,\n        {\n            ignoreError = false,\n            ignoreHistory = false\n        }: { ignoreError?: boolean; ignoreHistory?: boolean } = {}\n    ): FindResult<T>['store'] {\n        if (typeof path !== 'string')\n            throw new TypeError('Route path must be a string')\n\n        if (path === '') path = '/'\n        else if (path[0] !== '/') path = `/${path}`\n\n        const isWildcard = path[path.length - 1] === '*'\n        // End with ? and is param\n        const optionalParams = path.match(Memoirist.regex.optionalParams)\n\n        if (optionalParams) {\n            const originalPath = path.replaceAll('?', '')\n            this.add(method, originalPath, store, {\n                ignoreError\n            })\n\n            for (let i = 0; i < optionalParams.length; i++) {\n                let newPath = path.replace('/' + optionalParams[i], '')\n\n                this.add(method, newPath, store, {\n                    ignoreError: true\n                })\n            }\n\n            return store\n        }\n\n        if (optionalParams) path = path.replaceAll('?', '')\n\n        if (this.history.find(([m, p, s]) => m === method && p === path))\n            return store\n\n        if (\n            isWildcard ||\n            (optionalParams && path.charCodeAt(path.length - 1) === 63)\n        )\n            // Slice off trailing '*'\n            path = path.slice(0, -1)\n\n        if (!ignoreHistory) this.history.push([method, path, store])\n\n        const inertParts = path.split(Memoirist.regex.static)\n        const paramParts = path.match(Memoirist.regex.params) || []\n\n        if (inertParts[inertParts.length - 1] === '') inertParts.pop()\n\n        let node: Node<T>\n\n        if (!this.root[method]) node = this.root[method] = createNode<T>('/')\n        else node = this.root[method]\n\n        let paramPartsIndex = 0\n\n        for (let i = 0; i < inertParts.length; ++i) {\n            let part = inertParts[i]\n\n            if (i > 0) {\n                // Set param on the node\n                const param = paramParts[paramPartsIndex++].slice(1)\n\n                if (node.params === null) node.params = createParamNode(param)\n                else if (node.params.name !== param) {\n                    if (ignoreError) return store\n                    else\n                        throw new Error(\n                            `Cannot create route \"${path}\" with parameter \"${param}\" ` +\n                                'because a route already exists with a different parameter name ' +\n                                `(\"${node.params.name}\") in the same location`\n                        )\n                }\n\n                const params = node.params\n\n                if (params.inert === null) {\n                    node = params.inert = createNode(part)\n                    continue\n                }\n\n                node = params.inert\n            }\n\n            for (let j = 0; ; ) {\n                if (j === part.length) {\n                    if (j < node.part.length) {\n                        // Move the current node down\n                        const childNode = cloneNode(node, node.part.slice(j))\n                        Object.assign(node, createNode(part, [childNode]))\n                    }\n                    break\n                }\n\n                if (j === node.part.length) {\n                    // Add static child\n                    if (node.inert === null) node.inert = {}\n\n                    const inert = node.inert[part.charCodeAt(j)]\n\n                    if (inert) {\n                        // Re-run loop with existing static node\n                        node = inert\n                        part = part.slice(j)\n                        j = 0\n                        continue\n                    }\n\n                    // Create new node\n                    const childNode = createNode<T>(part.slice(j))\n                    node.inert[part.charCodeAt(j)] = childNode\n                    node = childNode\n\n                    break\n                }\n\n                if (part[j] !== node.part[j]) {\n                    // Split the node\n                    const existingChild = cloneNode(node, node.part.slice(j))\n                    const newChild = createNode<T>(part.slice(j))\n\n                    Object.assign(\n                        node,\n                        createNode(node.part.slice(0, j), [\n                            existingChild,\n                            newChild\n                        ])\n                    )\n\n                    node = newChild\n\n                    break\n                }\n\n                ++j\n            }\n        }\n\n        if (paramPartsIndex < paramParts.length) {\n            // The final part is a parameter\n            const param = paramParts[paramPartsIndex]\n            const name = param.slice(1)\n\n            if (node.params === null) node.params = createParamNode(name)\n            else if (node.params.name !== name) {\n                if (ignoreError) return store\n                else\n                    throw new Error(\n                        `Cannot create route \"${path}\" with parameter \"${name}\" ` +\n                            'because a route already exists with a different parameter name ' +\n                            `(\"${node.params.name}\") in the same location`\n                    )\n            }\n\n            if (node.params.store === null) node.params.store = store\n\n            return node.params.store!\n        }\n\n        if (isWildcard) {\n            // The final part is a wildcard\n            if (node.wildcardStore === null) node.wildcardStore = store\n\n            return node.wildcardStore!\n        }\n\n        // The final part is static\n        if (node.store === null) node.store = store\n\n        return node.store!\n    }\n\n    find(method: string, url: string): FindResult<T> | null {\n        const root = this.root[method]\n        if (!root) return null\n\n        return matchRoute(url, url.length, root, 0)\n    }\n}\n\nconst matchRoute = <T>(\n    url: string,\n    urlLength: number,\n    node: Node<T>,\n    startIndex: number\n): FindResult<T> | null => {\n    const part = node.part\n    const length = part.length\n    const endIndex = startIndex + length\n\n    // Only check the pathPart if its length is > 1 since the parent has\n    // already checked that the url matches the first character\n    if (length > 1) {\n        if (endIndex > urlLength) return null\n\n        // Using a loop is faster for short strings\n        if (length < 15) {\n            for (let i = 1, j = startIndex + 1; i < length; ++i, ++j)\n                if (part.charCodeAt(i) !== url.charCodeAt(j)) return null\n        } else if (url.slice(startIndex, endIndex) !== part) return null\n    }\n\n    // Reached the end of the URL\n    if (endIndex === urlLength) {\n        if (node.store !== null)\n            return {\n                store: node.store,\n                params: {}\n            }\n\n        if (node.wildcardStore !== null)\n            return {\n                store: node.wildcardStore,\n                params: { '*': '' }\n            }\n\n        return null\n    }\n\n    // Check for a static leaf\n    if (node.inert !== null) {\n        const inert = node.inert[url.charCodeAt(endIndex)]\n\n        if (inert !== undefined) {\n            const route = matchRoute(url, urlLength, inert, endIndex)\n\n            if (route !== null) return route\n        }\n    }\n\n    // Check for dynamic leaf\n    if (node.params !== null) {\n        const { store, name, inert } = node.params\n        const slashIndex = url.indexOf('/', endIndex)\n\n        if (slashIndex !== endIndex) {\n            // Params cannot be empty\n            if (slashIndex === -1 || slashIndex >= urlLength) {\n                if (store !== null) {\n                    // This is much faster than using a computed property\n                    const params: Record<string, string> = {}\n                    params[name] = url.substring(endIndex, urlLength)\n\n                    return {\n                        store,\n                        params\n                    }\n                }\n            } else if (inert !== null) {\n                const route = matchRoute(url, urlLength, inert, slashIndex)\n\n                if (route !== null) {\n                    route.params[name] = url.substring(endIndex, slashIndex)\n\n                    return route\n                }\n            }\n        }\n    }\n\n    // Check for wildcard leaf\n    if (node.wildcardStore !== null)\n        return {\n            store: node.wildcardStore,\n            params: {\n                '*': url.substring(endIndex, urlLength)\n            }\n        }\n\n    return null\n}\n\nexport default Memoirist\n"
  ],
  "mappings": ";AA/////fAmBA,IAAM,EAAa,CAAI,EAAc,IAA+B,CAChE,MAAM,EAA2C,GAAO,OAAS,CAAC,EAAI,KAEtE,GAAI,EACA,QAAW,KAAS,EAAQ,EAAS,EAAM,KAAK,WAAW,CAAC,GAAK,EAErE,MAAO,CACH,OACA,MAAO,KACP,MAAO,EACP,OAAQ,KACR,cAAe,IACnB,GAGE,EAAY,CAAI,EAAe,KAAkB,IAChD,EACH,MACJ,GAEM,EAAkB,CAAI,KAAgC,CACxD,OACA,MAAO,KACP,MAAO,IACX,GAEO,MAAM,CAAa,CACtB,KAAgC,CAAC,EACjC,QAAiC,CAAC,QAEnB,OAAQ,CACnB,OAAQ,eACR,OAAQ,gBACR,eAAgB,iBACpB,EAEA,GAAG,CACC,EACA,EACA,GAEI,cAAc,GACd,gBAAgB,IACoC,CAAC,EACnC,CACtB,UAAW,IAAS,SAChB,MAAM,IAAI,UAAU,6BAA6B,EAErD,GAAI,IAAS,GAAI,EAAO,YACf,EAAK,KAAO,IAAK,EAAO,IAAI,IAErC,MAAM,EAAa,EAAK,EAAK,OAAS,KAAO,IAEvC,EAAiB,EAAK,MAAM,EAAU,MAAM,cAAc,EAEhE,GAAI,EAAgB,CAChB,MAAM,EAAe,EAAK,WAAW,IAAK,EAAE,EAC5C,KAAK,IAAI,EAAQ,EAAc,EAAO,CAClC,aACJ,CAAC,EAED,QAAS,EAAI,EAAG,EAAI,EAAe,OAAQ,IAAK,CAC5C,IAAI,EAAU,EAAK,QAAQ,IAAM,EAAe,GAAI,EAAE,EAEtD,KAAK,IAAI,EAAQ,EAAS,EAAO,CAC7B,YAAa,EACjB,CAAC,EAGL,OAAO,EAGX,GAAI,EAAgB,EAAO,EAAK,WAAW,IAAK,EAAE,EAElD,GAAI,KAAK,QAAQ,KAAK,EAAE,EAAG,EAAG,KAAO,IAAM,GAAU,IAAM,CAAI,EAC3D,OAAO,EAEX,GACI,GACC,GAAkB,EAAK,WAAW,EAAK,OAAS,CAAC,IAAM,GAGxD,EAAO,EAAK,MAAM,GAAG,CAAE,EAE3B,IAAK,EAAe,KAAK,QAAQ,KAAK,CAAC,EAAQ,EAAM,CAAK,CAAC,EAE3D,MAAM,EAAa,EAAK,MAAM,EAAU,MAAM,MAAM,EAC9C,EAAa,EAAK,MAAM,EAAU,MAAM,MAAM,GAAK,CAAC,EAE1D,GAAI,EAAW,EAAW,OAAS,KAAO,GAAI,EAAW,IAAI,EAE7D,IAAI,EAEJ,IAAK,KAAK,KAAK,GAAS,EAAO,KAAK,KAAK,GAAU,EAAc,GAAG,MAC/D,GAAO,KAAK,KAAK,GAEtB,IAAI,EAAkB,EAEtB,QAAS,EAAI,EAAG,EAAI,EAAW,SAAU,EAAG,CACxC,IAAI,EAAO,EAAW,GAEtB,GAAI,EAAI,EAAG,CAEP,MAAM,EAAQ,EAAW,KAAmB,MAAM,CAAC,EAEnD,GAAI,EAAK,SAAW,KAAM,EAAK,OAAS,EAAgB,CAAK,UACpD,EAAK,OAAO,OAAS,EAC1B,GAAI,EAAa,OAAO,MAEpB,OAAM,IAAI,MACN,wBAAwB,sBAAyB,MAC7C,kEACA,KAAK,EAAK,OAAO,6BACzB,EAGR,MAAM,EAAS,EAAK,OAEpB,GAAI,EAAO,QAAU,KAAM,CACvB,EAAO,EAAO,MAAQ,EAAW,CAAI,EACrC,SAGJ,EAAO,EAAO,MAGlB,QAAS,EAAI,IAAO,CAChB,GAAI,IAAM,EAAK,OAAQ,CACnB,GAAI,EAAI,EAAK,KAAK,OAAQ,CAEtB,MAAM,EAAY,EAAU,EAAM,EAAK,KAAK,MAAM,CAAC,CAAC,EACpD,OAAO,OAAO,EAAM,EAAW,EAAM,CAAC,CAAS,CAAC,CAAC,EAErD,MAGJ,GAAI,IAAM,EAAK,KAAK,OAAQ,CAExB,GAAI,EAAK,QAAU,KAAM,EAAK,MAAQ,CAAC,EAEvC,MAAM,EAAQ,EAAK,MAAM,EAAK,WAAW,CAAC,GAE1C,GAAI,EAAO,CAEP,EAAO,EACP,EAAO,EAAK,MAAM,CAAC,EACnB,EAAI,EACJ,SAIJ,MAAM,EAAY,EAAc,EAAK,MAAM,CAAC,CAAC,EAC7C,EAAK,MAAM,EAAK,WAAW,CAAC,GAAK,EACjC,EAAO,EAEP,MAGJ,GAAI,EAAK,KAAO,EAAK,KAAK,GAAI,CAE1B,MAAM,EAAgB,EAAU,EAAM,EAAK,KAAK,MAAM,CAAC,CAAC,EAClD,EAAW,EAAc,EAAK,MAAM,CAAC,CAAC,EAE5C,OAAO,OACH,EACA,EAAW,EAAK,KAAK,MAAM,EAAG,CAAC,EAAG,CAC9B,EACA,CACJ,CAAC,CACL,EAEA,EAAO,EAEP,MAGJ,EAAE,GAIV,GAAI,EAAkB,EAAW,OAAQ,CAGrC,MAAM,EADQ,EAAW,GACN,MAAM,CAAC,EAE1B,GAAI,EAAK,SAAW,KAAM,EAAK,OAAS,EAAgB,CAAI,UACnD,EAAK,OAAO,OAAS,EAC1B,GAAI,EAAa,OAAO,MAEpB,OAAM,IAAI,MACN,wBAAwB,sBAAyB,MAC7C,kEACA,KAAK,EAAK,OAAO,6BACzB,EAGR,GAAI,EAAK,OAAO,QAAU,KAAM,EAAK,OAAO,MAAQ,EAEpD,OAAO,EAAK,OAAO,MAGvB,GAAI,EAAY,CAEZ,GAAI,EAAK,gBAAkB,KAAM,EAAK,cAAgB,EAEtD,OAAO,EAAK,cAIhB,GAAI,EAAK,QAAU,KAAM,EAAK,MAAQ,EAEtC,OAAO,EAAK,MAGhB,IAAI,CAAC,EAAgB,EAAmC,CACpD,MAAM,EAAO,KAAK,KAAK,GACvB,IAAK,EAAM,OAAO,KAElB,OAAO,EAAW,EAAK,EAAI,OAAQ,EAAM,CAAC,EAElD,CAEA,IAAM,EAAa,CACf,EACA,EACA,EACA,IACuB,CACvB,MAAM,EAAO,EAAK,KACZ,EAAS,EAAK,OACd,EAAW,EAAa,EAI9B,GAAI,EAAS,EAAG,CACZ,GAAI,EAAW,EAAW,OAAO,KAGjC,GAAI,EAAS,IACT,QAAS,EAAI,EAAG,EAAI,EAAa,EAAG,EAAI,IAAU,IAAK,EACnD,GAAI,EAAK,WAAW,CAAC,IAAM,EAAI,WAAW,CAAC,EAAG,OAAO,aAClD,EAAI,MAAM,EAAY,CAAQ,IAAM,EAAM,OAAO,KAIhE,GAAI,IAAa,EAAW,CACxB,GAAI,EAAK,QAAU,KACf,MAAO,CACH,MAAO,EAAK,MACZ,OAAQ,CAAC,CACb,EAEJ,GAAI,EAAK,gBAAkB,KACvB,MAAO,CACH,MAAO,EAAK,cACZ,OAAQ,CAAE,IAAK,EAAG,CACtB,EAEJ,OAAO,KAIX,GAAI,EAAK,QAAU,KAAM,CACrB,MAAM,EAAQ,EAAK,MAAM,EAAI,WAAW,CAAQ,GAEhD,GAAI,IAAU,OAAW,CACrB,MAAM,EAAQ,EAAW,EAAK,EAAW,EAAO,CAAQ,EAExD,GAAI,IAAU,KAAM,OAAO,GAKnC,GAAI,EAAK,SAAW,KAAM,CACtB,MAAQ,QAAO,OAAM,SAAU,EAAK,OAC9B,EAAa,EAAI,QAAQ,IAAK,CAAQ,EAE5C,GAAI,IAAe,GAEf,GAAI,KAAe,GAAM,GAAc,GACnC,GAAI,IAAU,KAAM,CAEhB,MAAM,EAAiC,CAAC,EAGxC,OAFA,EAAO,GAAQ,EAAI,UAAU,EAAU,CAAS,EAEzC,CACH,QACA,QACJ,WAEG,IAAU,KAAM,CACvB,MAAM,EAAQ,EAAW,EAAK,EAAW,EAAO,CAAU,EAE1D,GAAI,IAAU,KAGV,OAFA,EAAM,OAAO,GAAQ,EAAI,UAAU,EAAU,CAAU,EAEhD,IAOvB,GAAI,EAAK,gBAAkB,KACvB,MAAO,CACH,MAAO,EAAK,cACZ,OAAQ,CACJ,IAAK,EAAI,UAAU,EAAU,CAAS,CAC1C,CACJ,EAEJ,OAAO,MAGI",
  "debugId": "1E61A6F427AA7FBE64756e2164756e21",
  "names": []
}